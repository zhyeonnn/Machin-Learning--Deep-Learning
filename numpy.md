# numpy
### numpy를 사용하는 이유
 - array와 list에서 연산이 가장 빠르다
 - 대규모 수치 계산이 가능하다

### numpy의 배열 자료형인 ndarray
 - ndarray는 연산을 하기 위해 만들어진 벡터이기 때문에 모두 같은 자료형만 사용할 수 있다.

3차원은 시각화하기 매우 어렵다
3차원일 때 axis =0은 젤 앞 차원을 말한다

- **배열 생성**<br>

      ```python  
          a1 = np.array([1,2,3])
  
          a2 = np.array([[1,2.0,3.3],
                          [4,5,6.5]])
  
          a3 = np.array([[[1,2,3],
                          [4,5,6,],
                          [7,8,9]],
                          [[10,11,12],
                          [13,14,15],
                          [16,17,18]]])
      ```
- **shape**<br>
 -> `a1.shape`<br>
  (3,) -> 1차원<br>
  (2,3) -> 2차원, 2행3열, 배열 구조라고 생각하면 된다.<br>
  (2,3,3) -> 3차원<br>

- **ndim**<br>
 -> 몇차원인지<br>
- **dtype**<br>
 -> 데이터타입<br>
- **size**
 -> 데이터 총 수<br>
- **type()**
 -> `type(a1)` : a1의 타입(numpy.ndarray)<br>
- **.ones**<br>
 -> `np.ones((2,3))` : 2행 3열만큼의 크기를 1로 채우기<br>
- **.zeros**<br>
 -> `np.zeros((2,3))` : 2행 3열만큼의 크기를 0으로 채우기<br>
- **난수 생성**<br>
 -> `np.random.randint(0,10,size = (3,5))` : 0 ~ 10까지 3행5열에 맞추어 **정수 난수 생성**<br>
 -> `np.random.random((5,3))` : 0.0 ~ 1.0사이의 값의 난수를 생성<br>
 -> `np.random.seef(seed = 0)` : 매번 새로운 난수를 생성하면 값이 계속해서 변경되는데 seed를 사용하면 난수값을 고정시켜주는 역할을 한다, seed = 0일 때와 seed = 1일 때의 값이 다르게 나타난다. <br>
 
<br>
<br>
<br>
